name: CD

on:
  push:
    branches:
      - main
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'production'
        type: choice
        options:
          - production
          - staging

# Cancel in-progress runs when a new run is triggered
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

env:
  AWS_REGION: eu-south-2
  ECR_REPOSITORY: hermes

jobs:
  build-and-push:
    name: Build and Push Docker Image
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build, tag, and push image to Amazon ECR
        id: build-image
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          docker buildx build \
            --platform linux/arm64 \
            --push \
            --tag $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG \
            --tag $ECR_REGISTRY/$ECR_REPOSITORY:latest \
            --cache-from type=registry,ref=$ECR_REGISTRY/$ECR_REPOSITORY:buildcache \
            --cache-to type=registry,ref=$ECR_REGISTRY/$ECR_REPOSITORY:buildcache,mode=max \
            .
          echo "image=$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG" >> $GITHUB_OUTPUT

    outputs:
      image: ${{ steps.build-image.outputs.image }}

  deploy-infrastructure:
    name: Deploy Infrastructure with Terraform
    runs-on: ubuntu-latest
    needs: build-and-push

    defaults:
      run:
        working-directory: terraform

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.6.0

      - name: Terraform Init
        run: terraform init

      - name: Terraform Plan
        id: plan
        run: |
          terraform plan \
            -var="database_url=${{ secrets.DATABASE_URL }}" \
            -var="secret_key_base=${{ secrets.SECRET_KEY_BASE }}" \
            -var="anthropic_api_key=${{ secrets.ANTHROPIC_API_KEY }}" \
            -var="certificate_arn=${{ secrets.ACM_CERTIFICATE_ARN }}" \
            -var="key_name=${{ secrets.EC2_KEY_NAME }}" \
            -var="phx_host=${{ secrets.PHX_HOST }}" \
            -out=tfplan

      - name: Terraform Apply
        if: github.ref == 'refs/heads/main'
        run: terraform apply -auto-approve tfplan

      - name: Get Terraform Outputs
        id: get-outputs
        run: |
          # Blue-green infrastructure outputs
          echo "https_listener_arn=$(terraform output -raw https_listener_arn)" >> $GITHUB_OUTPUT
          echo "target_group_blue_arn=$(terraform output -raw target_group_blue_arn)" >> $GITHUB_OUTPUT
          echo "target_group_green_arn=$(terraform output -raw target_group_green_arn)" >> $GITHUB_OUTPUT
          echo "target_group_blue_name=$(terraform output -raw target_group_blue_name)" >> $GITHUB_OUTPUT
          echo "target_group_green_name=$(terraform output -raw target_group_green_name)" >> $GITHUB_OUTPUT
          terraform output -json blue_instance_ids > blue_ids.json
          terraform output -json green_instance_ids > green_ids.json
          echo "blue_instance_ids=$(cat blue_ids.json)" >> $GITHUB_OUTPUT
          echo "green_instance_ids=$(cat green_ids.json)" >> $GITHUB_OUTPUT

          # Assets outputs
          echo "assets_bucket=$(terraform output -raw assets_bucket_name)" >> $GITHUB_OUTPUT
          echo "assets_url=$(terraform output -raw assets_url)" >> $GITHUB_OUTPUT
          echo "cloudfront_id=$(terraform output -raw cloudfront_distribution_id)" >> $GITHUB_OUTPUT

    outputs:
      https_listener_arn: ${{ steps.get-outputs.outputs.https_listener_arn }}
      target_group_blue_arn: ${{ steps.get-outputs.outputs.target_group_blue_arn }}
      target_group_green_arn: ${{ steps.get-outputs.outputs.target_group_green_arn }}
      target_group_blue_name: ${{ steps.get-outputs.outputs.target_group_blue_name }}
      target_group_green_name: ${{ steps.get-outputs.outputs.target_group_green_name }}
      blue_instance_ids: ${{ steps.get-outputs.outputs.blue_instance_ids }}
      green_instance_ids: ${{ steps.get-outputs.outputs.green_instance_ids }}
      assets_bucket: ${{ steps.get-outputs.outputs.assets_bucket }}
      assets_url: ${{ steps.get-outputs.outputs.assets_url }}
      cloudfront_id: ${{ steps.get-outputs.outputs.cloudfront_id }}

  determine-deployment-target:
    name: Determine Blue-Green Target
    runs-on: ubuntu-latest
    needs: deploy-infrastructure

    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Determine active and inactive environments
        id: determine-target
        env:
          HTTPS_LISTENER_ARN: ${{ needs.deploy-infrastructure.outputs.https_listener_arn }}
          TARGET_GROUP_BLUE_ARN: ${{ needs.deploy-infrastructure.outputs.target_group_blue_arn }}
          TARGET_GROUP_GREEN_ARN: ${{ needs.deploy-infrastructure.outputs.target_group_green_arn }}
        run: |
          # Get the current active target group from the listener
          CURRENT_TG=$(aws elbv2 describe-listeners \
            --listener-arns "$HTTPS_LISTENER_ARN" \
            --query 'Listeners[0].DefaultActions[0].TargetGroupArn' \
            --output text)

          echo "Current active target group: $CURRENT_TG"

          # Determine which environment to deploy to (the inactive one)
          if [ "$CURRENT_TG" == "$TARGET_GROUP_BLUE_ARN" ]; then
            echo "Blue is active, deploying to GREEN"
            echo "deploy_to=green" >> $GITHUB_OUTPUT
            echo "active_env=blue" >> $GITHUB_OUTPUT
            echo "deploy_tg_arn=$TARGET_GROUP_GREEN_ARN" >> $GITHUB_OUTPUT
            echo "active_tg_arn=$TARGET_GROUP_BLUE_ARN" >> $GITHUB_OUTPUT
          else
            echo "Green is active, deploying to BLUE"
            echo "deploy_to=blue" >> $GITHUB_OUTPUT
            echo "active_env=green" >> $GITHUB_OUTPUT
            echo "deploy_tg_arn=$TARGET_GROUP_BLUE_ARN" >> $GITHUB_OUTPUT
            echo "active_tg_arn=$TARGET_GROUP_GREEN_ARN" >> $GITHUB_OUTPUT
          fi

    outputs:
      deploy_to: ${{ steps.determine-target.outputs.deploy_to }}
      active_env: ${{ steps.determine-target.outputs.active_env }}
      deploy_tg_arn: ${{ steps.determine-target.outputs.deploy_tg_arn }}
      active_tg_arn: ${{ steps.determine-target.outputs.active_tg_arn }}

  upload-assets:
    name: Upload Static Assets to S3
    runs-on: ubuntu-latest
    needs: [build-and-push, deploy-infrastructure]

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Extract static assets from Docker image
        env:
          IMAGE: ${{ needs.build-and-push.outputs.image }}
        run: |
          # Pull the ARM64 image (need to specify platform since runner is amd64)
          docker pull --platform linux/arm64 $IMAGE
          # Create a container from the image (don't run it)
          docker create --platform linux/arm64 --name assets-extractor $IMAGE
          # Copy static assets from the container
          docker cp assets-extractor:/app/lib/hermes-0.1.0/priv/static ./static
          # Remove the container
          docker rm assets-extractor
          # List extracted files
          ls -la ./static/

      - name: Upload assets to S3
        env:
          ASSETS_BUCKET: ${{ needs.deploy-infrastructure.outputs.assets_bucket }}
        run: |
          # Also copy static files from source (images, favicon, etc.)
          cp -r $GITHUB_WORKSPACE/priv/static/images ./static/ 2>/dev/null || true
          cp $GITHUB_WORKSPACE/priv/static/favicon.ico ./static/ 2>/dev/null || true
          cp $GITHUB_WORKSPACE/priv/static/robots.txt ./static/ 2>/dev/null || true

          # List what we're uploading
          echo "Static files to upload:"
          ls -la ./static/

          # Remove any .DS_Store files before uploading
          find ./static -name ".DS_Store" -delete

          # Sync assets to S3 with appropriate cache headers
          # Fingerprinted assets get long cache (1 year)
          aws s3 sync ./static/assets s3://$ASSETS_BUCKET/assets \
            --cache-control "public, max-age=31536000, immutable" \
            --exclude ".DS_Store" \
            --delete

          # Other static files get shorter cache (1 day)
          aws s3 sync ./static s3://$ASSETS_BUCKET \
            --exclude "assets/*" \
            --exclude ".DS_Store" \
            --cache-control "public, max-age=86400" \
            --delete

      - name: Invalidate CloudFront cache
        env:
          CLOUDFRONT_ID: ${{ needs.deploy-infrastructure.outputs.cloudfront_id }}
        run: |
          aws cloudfront create-invalidation \
            --distribution-id $CLOUDFRONT_ID \
            --paths "/*"

  run-migrations:
    name: Run Database Migrations
    runs-on: ubuntu-latest
    needs: [build-and-push, deploy-infrastructure, determine-deployment-target]

    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Run Database Migrations
        env:
          IMAGE: ${{ needs.build-and-push.outputs.image }}
          DEPLOY_TO: ${{ needs.determine-deployment-target.outputs.deploy_to }}
          BLUE_INSTANCE_IDS: ${{ needs.deploy-infrastructure.outputs.blue_instance_ids }}
          GREEN_INSTANCE_IDS: ${{ needs.deploy-infrastructure.outputs.green_instance_ids }}
        run: |
          # Get one instance from the deployment target to run migrations
          if [ "$DEPLOY_TO" == "blue" ]; then
            INSTANCE_ID=$(echo "$BLUE_INSTANCE_IDS" | jq -r '.[0]')
          else
            INSTANCE_ID=$(echo "$GREEN_INSTANCE_IDS" | jq -r '.[0]')
          fi

          echo "Running migrations on $INSTANCE_ID ($DEPLOY_TO environment)..."

          COMMAND_ID=$(aws ssm send-command \
            --instance-ids "$INSTANCE_ID" \
            --document-name "AWS-RunShellScript" \
            --parameters commands="[
              \"aws ecr get-login-password --region ${{ env.AWS_REGION }} | docker login --username AWS --password-stdin ${{ steps.login-ecr.outputs.registry }}\",
              \"docker pull ${{ needs.build-and-push.outputs.image }}\",
              \"printf 'DATABASE_URL=${{ secrets.DATABASE_URL }}\\nSECRET_KEY_BASE=${{ secrets.SECRET_KEY_BASE }}\\nPOOL_SIZE=2\\n' > /tmp/migrate.env\",
              \"docker run --rm --env-file /tmp/migrate.env ${{ needs.build-and-push.outputs.image }} /app/bin/hermes eval 'Hermes.Release.migrate()'\",
              \"rm /tmp/migrate.env\"
            ]" \
            --query 'Command.CommandId' \
            --output text)

          echo "Migration Command ID: $COMMAND_ID"

          # Wait for migrations to complete
          aws ssm wait command-executed \
            --command-id "$COMMAND_ID" \
            --instance-id "$INSTANCE_ID" || true

          STATUS=$(aws ssm get-command-invocation \
            --command-id "$COMMAND_ID" \
            --instance-id "$INSTANCE_ID" \
            --query 'Status' \
            --output text)

          echo "Migration status: $STATUS"

          if [ "$STATUS" != "Success" ]; then
            echo "Migration output:"
            aws ssm get-command-invocation \
              --command-id "$COMMAND_ID" \
              --instance-id "$INSTANCE_ID" \
              --query 'StandardOutputContent' \
              --output text
            echo "Migration errors:"
            aws ssm get-command-invocation \
              --command-id "$COMMAND_ID" \
              --instance-id "$INSTANCE_ID" \
              --query 'StandardErrorContent' \
              --output text
            exit 1
          fi

          echo "Migrations completed successfully"

  deploy-to-inactive:
    name: Deploy to Inactive Environment
    runs-on: ubuntu-latest
    needs: [build-and-push, deploy-infrastructure, determine-deployment-target, upload-assets, run-migrations]

    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Deploy to inactive environment
        env:
          IMAGE: ${{ needs.build-and-push.outputs.image }}
          DEPLOY_TO: ${{ needs.determine-deployment-target.outputs.deploy_to }}
          BLUE_INSTANCE_IDS: ${{ needs.deploy-infrastructure.outputs.blue_instance_ids }}
          GREEN_INSTANCE_IDS: ${{ needs.deploy-infrastructure.outputs.green_instance_ids }}
          ASSETS_URL: ${{ needs.deploy-infrastructure.outputs.assets_url }}
        run: |
          echo "Deploying to $DEPLOY_TO environment..."

          # Get instance IDs for the target environment
          if [ "$DEPLOY_TO" == "blue" ]; then
            INSTANCE_IDS=$(echo "$BLUE_INSTANCE_IDS" | jq -r '.[]')
          else
            INSTANCE_IDS=$(echo "$GREEN_INSTANCE_IDS" | jq -r '.[]')
          fi

          for INSTANCE_ID in $INSTANCE_IDS; do
            echo "Deploying to $INSTANCE_ID ($DEPLOY_TO)..."

            COMMAND_ID=$(aws ssm send-command \
              --instance-ids "$INSTANCE_ID" \
              --document-name "AWS-RunShellScript" \
              --parameters commands="[
                \"aws ecr get-login-password --region ${{ env.AWS_REGION }} | docker login --username AWS --password-stdin ${{ steps.login-ecr.outputs.registry }}\",
                \"docker pull ${{ needs.build-and-push.outputs.image }}\",
                \"docker stop hermes || true\",
                \"docker rm hermes || true\",
                \"printf 'DATABASE_URL=${{ secrets.DATABASE_URL }}\\nSECRET_KEY_BASE=${{ secrets.SECRET_KEY_BASE }}\\nANTHROPIC_API_KEY=${{ secrets.ANTHROPIC_API_KEY }}\\nPHX_HOST=${{ secrets.PHX_HOST }}\\nSTATIC_URL=${{ needs.deploy-infrastructure.outputs.assets_url }}\\nPHX_SERVER=true\\nPORT=4000\\nMIX_ENV=prod\\nPOOL_SIZE=5\\n' > /opt/hermes/.env\",
                \"docker run -d --name hermes --restart unless-stopped -p 4000:4000 --env-file /opt/hermes/.env ${{ needs.build-and-push.outputs.image }}\",
                \"sleep 15\",
                \"docker logs hermes 2>&1 | tail -50 || true\",
                \"curl -f http://localhost:4000/health || (docker logs hermes 2>&1 | tail -100 && exit 1)\"
              ]" \
              --query 'Command.CommandId' \
              --output text)

            echo "Command ID: $COMMAND_ID"

            # Wait for command to complete
            aws ssm wait command-executed \
              --command-id "$COMMAND_ID" \
              --instance-id "$INSTANCE_ID" || true

            STATUS=$(aws ssm get-command-invocation \
              --command-id "$COMMAND_ID" \
              --instance-id "$INSTANCE_ID" \
              --query 'Status' \
              --output text)

            echo "Command status: $STATUS"

            if [ "$STATUS" != "Success" ]; then
              echo "Command output:"
              aws ssm get-command-invocation \
                --command-id "$COMMAND_ID" \
                --instance-id "$INSTANCE_ID" \
                --query 'StandardOutputContent' \
                --output text
              echo "Command errors:"
              aws ssm get-command-invocation \
                --command-id "$COMMAND_ID" \
                --instance-id "$INSTANCE_ID" \
                --query 'StandardErrorContent' \
                --output text
              exit 1
            fi

            echo "Deployment to $INSTANCE_ID completed successfully"
          done

  verify-deployment:
    name: Verify Inactive Environment Health
    runs-on: ubuntu-latest
    needs: [deploy-infrastructure, determine-deployment-target, deploy-to-inactive]

    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Verify instances are healthy via SSM
        env:
          DEPLOY_TO: ${{ needs.determine-deployment-target.outputs.deploy_to }}
          BLUE_INSTANCE_IDS: ${{ needs.deploy-infrastructure.outputs.blue_instance_ids }}
          GREEN_INSTANCE_IDS: ${{ needs.deploy-infrastructure.outputs.green_instance_ids }}
        run: |
          echo "Verifying $DEPLOY_TO instances are healthy..."

          # Get instance IDs for the target environment
          if [ "$DEPLOY_TO" == "blue" ]; then
            INSTANCE_IDS=$(echo "$BLUE_INSTANCE_IDS" | jq -r '.[]')
          else
            INSTANCE_IDS=$(echo "$GREEN_INSTANCE_IDS" | jq -r '.[]')
          fi

          ALL_HEALTHY=true
          for INSTANCE_ID in $INSTANCE_IDS; do
            echo "Checking health of $INSTANCE_ID..."

            COMMAND_ID=$(aws ssm send-command \
              --instance-ids "$INSTANCE_ID" \
              --document-name "AWS-RunShellScript" \
              --parameters commands='["curl -sf http://localhost:4000/health || exit 1"]' \
              --query 'Command.CommandId' \
              --output text)

            # Wait for command to complete
            sleep 5
            aws ssm wait command-executed \
              --command-id "$COMMAND_ID" \
              --instance-id "$INSTANCE_ID" || true

            STATUS=$(aws ssm get-command-invocation \
              --command-id "$COMMAND_ID" \
              --instance-id "$INSTANCE_ID" \
              --query 'Status' \
              --output text)

            if [ "$STATUS" == "Success" ]; then
              echo "✅ Instance $INSTANCE_ID is healthy"
            else
              echo "❌ Instance $INSTANCE_ID health check failed"
              aws ssm get-command-invocation \
                --command-id "$COMMAND_ID" \
                --instance-id "$INSTANCE_ID" \
                --query 'StandardErrorContent' \
                --output text
              ALL_HEALTHY=false
            fi
          done

          if [ "$ALL_HEALTHY" == "true" ]; then
            echo "All $DEPLOY_TO instances are healthy!"
          else
            echo "ERROR: Some instances failed health check"
            exit 1
          fi

  switch-traffic:
    name: Switch Traffic to New Environment
    runs-on: ubuntu-latest
    needs: [deploy-infrastructure, determine-deployment-target, verify-deployment]

    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Switch ALB traffic to new environment
        env:
          HTTPS_LISTENER_ARN: ${{ needs.deploy-infrastructure.outputs.https_listener_arn }}
          DEPLOY_TG_ARN: ${{ needs.determine-deployment-target.outputs.deploy_tg_arn }}
          DEPLOY_TO: ${{ needs.determine-deployment-target.outputs.deploy_to }}
          ACTIVE_ENV: ${{ needs.determine-deployment-target.outputs.active_env }}
        run: |
          echo "Switching traffic from $ACTIVE_ENV to $DEPLOY_TO..."

          # Update the listener to point to the new target group
          aws elbv2 modify-listener \
            --listener-arn "$HTTPS_LISTENER_ARN" \
            --default-actions Type=forward,TargetGroupArn="$DEPLOY_TG_ARN"

          echo "Traffic switched successfully!"
          echo "New active environment: $DEPLOY_TO"
          echo "Previous environment ($ACTIVE_ENV) is still running for quick rollback if needed"

  notify:
    name: Notify Deployment Status
    runs-on: ubuntu-latest
    needs: [build-and-push, deploy-infrastructure, determine-deployment-target, switch-traffic]
    if: always()

    steps:
      - name: Deployment Status
        env:
          DEPLOY_TO: ${{ needs.determine-deployment-target.outputs.deploy_to }}
          ACTIVE_ENV: ${{ needs.determine-deployment-target.outputs.active_env }}
        run: |
          if [ "${{ needs.switch-traffic.result }}" == "success" ]; then
            echo "✅ Blue-Green Deployment succeeded!"
            echo "Image: ${{ needs.build-and-push.outputs.image }}"
            echo "Traffic switched from $ACTIVE_ENV to $DEPLOY_TO"
            echo ""
            echo "To rollback, manually switch the ALB listener back to $ACTIVE_ENV target group"
          else
            echo "❌ Deployment failed!"
            echo "Active environment ($ACTIVE_ENV) is still serving traffic"
            exit 1
          fi
